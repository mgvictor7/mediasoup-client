/**
 * Fill the given RTP parameters for the given track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
export function fillRtpParametersForTrack(rtpParameters, sdpObj, track)
{
	const kind = track.kind;
	const rtcp =
	{
		cname       : null,
		reducedSize : true,
		mux         : true
	};

	const mSection = (sdpObj.media || [])
		.find((m) =>
		{
			if (m.type !== kind)
				return;

			const msidLine = m.msid;

			if (!msidLine)
				return;

			const trackId = msidLine.split(' ')[1];

			if (trackId === track.id)
				return true;
		});

	if (!mSection)
		throw new Error(`m=${kind} section not found`);

	// Get the SSRC and CNAME.

	const ssrcCnameLine = (mSection.ssrcs || [])
		.find((line) => line.attribute === 'cname');

	let ssrc;

	if (ssrcCnameLine)
	{
		ssrc = ssrcCnameLine.id;
		rtcp.cname = ssrcCnameLine.value;
	}

	// Get a=rid lines.

	// Array of Objects with rid and profile keys.
	const simulcastStreams = [];

	for (const rid of mSection.rids || [])
	{
		if (rid.direction !== 'send')
			continue;

		if (/^low/.test(rid.id))
			simulcastStreams.push({ rid: rid.id, profile: 'low' });
		else if (/^medium/.test(rid.id))
			simulcastStreams.push({ rid: rid.id, profile: 'medium' });
		if (/^high/.test(rid.id))
			simulcastStreams.push({ rid: rid.id, profile: 'high' });
	}

	// Fill RTP parameters.

	rtpParameters.rtcp = rtcp;
	rtpParameters.encodings = [];

	if (simulcastStreams.length === 0)
	{
		const encoding = { ssrc };

		rtpParameters.encodings.push(encoding);
	}
	else
	{
		for (const simulcastStream of simulcastStreams)
		{
			const encoding =
			{
				encodingId : simulcastStream.rid,
				profile    : simulcastStream.profile
			};

			rtpParameters.encodings.push(encoding);
		}
	}
}
